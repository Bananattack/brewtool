<!doctype html>
<html>
<head>
    <meta charset="utf-8"></meta>
    <title>map zapper</title>
    <style rel="stylesheet" type="text/css" href="../css/maptool.css">
html, body {
    padding: 0;
    margin: 0;
    font-family: Georgia, 'Times New Roman', serif;
    background-color: #FBFBFB;
    color: #333333;
}

.page {
    margin: 64px;
    border: 8px solid #E0F0F0;
    background-color: #E8F8F8;
    box-shadow: 0px 0px 127px #CCCCCC;
    text-shadow: 1px 1px 1px #AA77DD;
    border-radius: 32px;
    padding: 32px;
}

a, a:visited {
    border: 0;
    cursor: pointer;
    text-decoration: none;
    color: #54D0E7;
    text-shadow: 1px 1px 1px #9966CC;
}

h1 a, h1 a:visited {
    color: #F7B4C0;
    text-shadow: 1px 1px 1px #9966CC;
}


a:hover, a:active {
    opacity: 0.5;
}

.page a {
    font-style: normal;
}

.page .editor h2 {
    border-bottom: 2px solid #E0F0F0;
}

.file_picker {
    position:relative;
    color: #54D0E7;
    overflow: hidden;
    width: 100px;
}

.file_picker input {
    z-index: 1;
    opacity: 0;
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    cursor: pointer;
}

.file_picker:hover {
    opacity: 0.5;
}

.hidden {
    display: none;
}


.palettes table,
.palettes table tr,
.palettes table tr td {
    border-collapse: collapse;
    border-spacing: 0;
}

.palettes th {
    width: 32px;
}

.palettes td {
    height: 16px;
    min-height: 16px;
}

.palettes td .color {
    width: 16px;
    height: 16px;
    max-width: 16px;
    max-height: 16px;
    margin: 4px;
    margin-left: auto;
    margin-right: auto;
    border: 1px solid #333333;
}

.footnote {
    font-size: 0.8em;
    font-style: italic;
    padding-top: 16px;
    color: #C0D0D0;
    text-align: right;
}
</style>
    <script type="text/javascript">
var editor = (function(self) {
    var saveAs =
        window.webkitSaveAs
        || window.mozSaveAs
        || window.msSaveAs
        || window.navigator.msSaveBlob && function(blob, name) {
                    return window.navigator.msSaveBlob(blob, name);
            }
        || function(blob, name) {
            var click = document.createEvent("MouseEvent");
            click.initMouseEvent("click", true, true, window, 0, 
                event.screenX, event.screenY, event.clientX, event.clientY, 
                event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, 
                0, null);
            var a = document.createElement('a');
            a.setAttribute('href', URL.createObjectURL(blob));
            a.setAttribute('download', name);
            a.dispatchEvent(click);
        };

    var dataUrlToBlob = function(url) {
        var parts = url.split(',');
        var contentType = parts[0].split(':')[1].split(';');
        var mimeType = contentType[0];
        var encoding = contentType[1];
        var data = parts[1];

        if (encoding == 'base64') {
            var bytes = window.atob(data);
            var buffer = new Uint8Array(bytes.length);
            for (var i = 0; i < bytes.length; i++) {
                buffer[i] = bytes.charCodeAt(i);
            }
            return new Blob([buffer], {type: mimeType});
        } else {
            return new Blob([data], {type: mimeType});
        }
    }

    var canvasToBlob = function(canvas, callback) {
        if(canvas.toBlob) {
            canvas.toBlob(callback);
        } else {
            callback(dataUrlToBlob(canvas.toDataURL()));
        }
    }

    var inputCanvas = null;
    var filePicker = null;
    var currentFile = null;
    var tilesetContainer = null;
    var paletteContainer = null;
    var mapContainer = null;
    var removeDuplicatesCheckbox = null;
    var commonBackgroundCheckbox = null;
    var tileLimitField = null;

    var restrictions = {
        tiles: {
            width: 8,
            height: 8,
            max: 256,
            removeDuplicates: true
        },
        attributes: {
            width: 8,
            height: 8
        },
        colors: {
            max: 4
        },
        palettes: {
            max: 8,
            combineIncompleteEntries: true,
            commonBackgroundMode: false,
        }
    }
    var currentMap = null;


    self.init = function(config) {
        var div = document.createElement('div');
        div.className = 'section';
        var h2 = document.createElement('h2');
        h2.appendChild(document.createTextNode('Input'));
        div.appendChild(h2);
        var p = document.createElement('p');
        p.appendChild(document.createTextNode('Source file may be .png or .gif. You can drag and drop files here. Files must adhere to GBC background specs: 4 colors max per 8x8 region, 8 palettes max'));
        div.appendChild(p);
        var p = document.createElement('p');
        p.appendChild(document.createTextNode('Tile limit: '));
        tileLimitField = document.createElement('input');
        tileLimitField.setAttribute('type', 'text');
        tileLimitField.setAttribute('value', '256');
        p.appendChild(tileLimitField);
        p.appendChild(document.createTextNode('\u00A0\u00A0\u00A0\u00A0'));
        removeDuplicatesCheckbox = document.createElement('input');
        removeDuplicatesCheckbox.setAttribute('type', 'checkbox');
        removeDuplicatesCheckbox.setAttribute('value', '');
        removeDuplicatesCheckbox.setAttribute('checked', 'checked');
        p.appendChild(removeDuplicatesCheckbox);
        p.appendChild(document.createTextNode('Remove Duplicate Tiles'));
        p.appendChild(document.createTextNode('\u00A0\u00A0\u00A0\u00A0'));
        commonBackgroundCheckbox = document.createElement('input');
        commonBackgroundCheckbox.setAttribute('type', 'checkbox');
        commonBackgroundCheckbox.setAttribute('value', '');
        commonBackgroundCheckbox.removeAttribute('checked');
        p.appendChild(commonBackgroundCheckbox);
        p.appendChild(document.createTextNode('Common Background (color at 0, 0 should be bg color)'));

        div.appendChild(p);
        var fileContainer = document.createElement('div');
        fileContainer.className = 'file_picker';
        var p = document.createElement('p');
        p.appendChild(document.createTextNode('Browse...'));
        fileContainer.appendChild(p);
        filePicker = document.createElement('input');
        filePicker.setAttribute('type', 'file');
        filePicker.addEventListener('change', self.changeFile);
        fileContainer.appendChild(filePicker);
        div.appendChild(fileContainer);
        inputCanvas = document.createElement('canvas');
        inputCanvas.appendChild(document.createTextNode('This application requires HTML5 support.'));
        inputCanvas.width = 0;
        inputCanvas.height = 0;
        div.appendChild(inputCanvas);
        config.element.appendChild(div);

        tilesetContainer = document.createElement('div');
        tilesetContainer.className = 'hidden';
        config.element.appendChild(tilesetContainer);

        paletteContainer = document.createElement('div');
        paletteContainer.className = 'hidden';
        config.element.appendChild(paletteContainer);

        mapContainer = document.createElement('div');
        mapContainer.className = 'hidden';
        config.element.appendChild(mapContainer);

        document.ondragover = function() { return false; };
        document.ondragend = function() { return false; };
        document.ondrop = self.changeFile;
    }

    self.changeFile = function(event) {
        event.preventDefault();

        var files = (event.dataTransfer ? event.dataTransfer : event.target).files;
        if(files.length) {
            var file = files[0];
            currentFile = file;
            inputCanvas.style.display = 'none';
            tilesetContainer.className = 'hidden';
            paletteContainer.className = 'hidden';
            self.loadFile(file);
        }
        return false;
    };

    self.saveCHR = function(event) {
        event.preventDefault();

        if(currentFile === null) {
            return false;
        }

        var parts = currentFile.name.split('.');
        parts.pop();
        brewtool.saveTileset(currentMap.tileMap.tileCanvas, 'GB', brewtool.getGreyscalePalette(),
            function(blob) {
                saveAs(blob, parts.join('.') + '.chr');
            }
        );

        return false;
    };

    self.saveTilePNG = function(event) {
        event.preventDefault();

        if(currentFile === null) {
            return false;
        }

        var parts = currentFile.name.split('.');
        parts.pop();
        canvasToBlob(currentMap.tileMap.tileCanvas,
            function(blob) {
                saveAs(blob, parts.join('.') + '.tiles.png');
            }
        );

        return false;
    };

    self.saveCombinedPNG = function(event) {
        event.preventDefault();

        if(currentFile === null) {
            return false;
        }


        var palettes = currentMap.attributeMap.palettes;

        var canvas = document.createElement('canvas');
        var context = canvas.getContext('2d')
        canvas.width = currentMap.tileMap.tileCanvas.width;
        canvas.height = currentMap.tileMap.tileCanvas.height * palettes.length;
        console.log(currentMap.tileMap.tileCanvas.height, canvas.height);
        for(var i = 0; i < palettes.length; i++) {
            var ts = createTilesetImage(currentMap.tileMap.tiles, palettes[i].colors.values);            
            context.drawImage(ts, 0, i * currentMap.tileMap.tileCanvas.height);
            console.log(canvas, 0, i * currentMap.tileMap.tileCanvas.height)
        }

        var parts = currentFile.name.split('.');
        parts.pop();
        canvasToBlob(canvas,
            function(blob) {
                saveAs(blob, parts.join('.') + '.combined.png');
            }
        );

        return false;
    };

    self.savePal = function(event) {
        event.preventDefault();

        if(currentFile === null) {
            return false;
        }

        var out = [];
        var palettes = currentMap.attributeMap.palettes;
        for(var i = 0; i < palettes.length; i++) {
            var palette = palettes[i].colors.values;
            while(palette.length < 4) {
                palette.push([0, 0, 0]);
            }
            out.push(palette)
        }

        var parts = currentFile.name.split('.');
        parts.pop();
        brewtool.savePalettes(out, function(blob) {
            saveAs(blob, parts.join('.') + '.pal');
        });

        return false;
    };

    self.saveAttrPNG = function(event) {
        event.preventDefault();

        if(currentFile === null) {
            return false;
        }

        var canvas = document.createElement('canvas');
        var palettes = currentMap.attributeMap.palettes;

        canvas.width = restrictions.attributes.width;
        canvas.height = restrictions.attributes.height * palettes.length;
        var out = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
        var p = 0;
        for(var i = 0; i < palettes.length; i++) {
            var palette = palettes[i].colors.values;
            for(var j = 0; j < restrictions.attributes.width * restrictions.attributes.height; j++) {
                var k = Math.floor((j % restrictions.attributes.width) * palette.length / restrictions.attributes.width);
                var c = palette[k] || [0, 0, 0, 0];

                out.data[p++] = c[0];
                out.data[p++] = c[1];
                out.data[p++] = c[2];
                out.data[p++] = c[3];
            }
        }
        canvas.getContext('2d').putImageData(out, 0, 0);

        var parts = currentFile.name.split('.');
        parts.pop();
        canvasToBlob(canvas,
            function(blob) {
                saveAs(blob, parts.join('.') + '.attributes.png');
            }
        );

        return false;
    };

    self.saveTileMapCSV = function(event) {
        event.preventDefault();

        var rows = [];
        var tileMap = currentMap.tileMap;
        for(var j = 0; j < tileMap.height; j++) {
            var row = [];
            for(var i = 0; i < tileMap.width; i++) {
                row.push(tileMap.data[j * tileMap.width + i]);
            }
            rows.push(row.join(','));
        }

        var parts = currentFile.name.split('.');
        parts.pop();
        saveAs(new Blob([rows.join('\n')], {type: "application/octet-stream"}), parts.join('.') + '.tiles.csv');

        return false;
    }


    self.saveAttrMapCSV = function(event) {
        event.preventDefault();

        var rows = [];
        var attributeMap = currentMap.attributeMap;
        for(var j = 0; j < attributeMap.height; j++) {
            var row = [];
            for(var i = 0; i < attributeMap.width; i++) {
                row.push(attributeMap.data[j * attributeMap.width + i]);
            }
            rows.push(row.join(','));
        }

        var parts = currentFile.name.split('.');
        parts.pop();
        saveAs(new Blob([rows.join('\n')], {type: "application/octet-stream"}), parts.join('.') + '.attributes.csv');

        return false;
    }

    self.saveTileMapDat = function(event) {
        event.preventDefault();

        var tileMap = currentMap.tileMap;
        var bytes = [
            tileMap.width & 0xFF, (tileMap.width >> 8) & 0xFF,
            tileMap.height & 0xFF, (tileMap.height >> 8) & 0xFF,
        ];
        for(var j = 0; j < tileMap.height; j++) {
            for(var i = 0; i < tileMap.width; i++) {
                bytes.push(tileMap.data[j * tileMap.width + i]);
            }
        }

        var buffer = new Uint8Array(new ArrayBuffer(bytes.length));
        for(var i = 0; i < bytes.length; i++) {
            buffer[i] = bytes[i];
        }

        var parts = currentFile.name.split('.');
        parts.pop();
        saveAs(new Blob([buffer], {type: "application/octet-stream"}), parts.join('.') + '.tiles.dat');

        return false;
    }


    self.saveAttrMapDat = function(event) {
        event.preventDefault();

        var attributeMap = currentMap.attributeMap;
        var bytes = [
            attributeMap.width & 0xFF, (attributeMap.width >> 8) & 0xFF,
            attributeMap.height & 0xFF, (attributeMap.height >> 8) & 0xFF,
        ];
        for(var j = 0; j < attributeMap.height; j++) {
            for(var i = 0; i < attributeMap.width; i++) {
                bytes.push(attributeMap.data[j * attributeMap.width + i]);
            }
        }

        var buffer = new Uint8Array(new ArrayBuffer(bytes.length));
        for(var i = 0; i < bytes.length; i++) {
            buffer[i] = bytes[i];
        }

        var parts = currentFile.name.split('.');
        parts.pop();
        saveAs(new Blob([buffer], {type: "application/octet-stream"}), parts.join('.') + '.attributes.dat');

        return false;
    }

    self.saveCombinedMapCSV = function(event) {
        event.preventDefault();

        if(restrictions.attributes.width % restrictions.tiles.width != 0 || restrictions.attributes.height % restrictions.tiles.height != 0) {
            alert('Attribute size ' + restrictions.attributes.width + 'x' + restrictions.attributes.height + ' is not divisble by tile size of ' + restrictions.tiles.width + 'x' + restrictions.tiles.height);
        }

        var rows = [];
        var tileMap = currentMap.tileMap;
        var attributeMap = currentMap.attributeMap;
        var attrColPerTile = restrictions.attributes.width / restrictions.tiles.width;
        var attrRowPerTile = restrictions.attributes.height / restrictions.tiles.height;
        var tilesPerTileset = Math.ceil(currentMap.tileMap.tiles.length / 16) * 16;

        for(var j = 0; j < tileMap.height; j++) {
            var row = [];
            for(var i = 0; i < tileMap.width; i++) {
                var attr = attributeMap.data[Math.floor(j / attrRowPerTile) * attributeMap.width + Math.floor(i / attrColPerTile)]
                var tile = tileMap.data[j * tileMap.width + i];
                row.push(attr * tilesPerTileset + tile);
            }
            rows.push(row.join(','));
        }

        var parts = currentFile.name.split('.');
        parts.pop();
        saveAs(new Blob([rows.join('\n')], {type: "application/octet-stream"}), parts.join('.') + '.combined.csv');

        return false;
    }

    self.saveCombinedMapTiled = function(event) {
        event.preventDefault();

        if(restrictions.attributes.width % restrictions.tiles.width != 0 || restrictions.attributes.height % restrictions.tiles.height != 0) {
            alert('Attribute size ' + restrictions.attributes.width + 'x' + restrictions.attributes.height + ' is not divisble by tile size of ' + restrictions.tiles.width + 'x' + restrictions.tiles.height);
        }

        var rows = [];
        var tileMap = currentMap.tileMap;
        var attributeMap = currentMap.attributeMap;
        var attrColPerTile = restrictions.attributes.width / restrictions.tiles.width;
        var attrRowPerTile = restrictions.attributes.height / restrictions.tiles.height;
        var tilesPerTileset = Math.ceil(currentMap.tileMap.tiles.length / 16) * 16;

        for(var j = 0; j < tileMap.height; j++) {
            var row = [];
            for(var i = 0; i < tileMap.width; i++) {
                var attr = attributeMap.data[Math.floor(j / attrRowPerTile) * attributeMap.width + Math.floor(i / attrColPerTile)]
                var tile = tileMap.data[j * tileMap.width + i];
                row.push(attr * tilesPerTileset + tile + 1);
            }
            rows.push(row.join(','));
        }

        var parts = currentFile.name.split('.');
        parts.pop();

        var text = '<?xml version="1.0" encoding="UTF-8"?>\n'
            + '<map version="1.0" orientation="orthogonal" width="' + tileMap.width + '" '
            + 'height="' + tileMap.height + '" '
            + 'tilewidth="' + restrictions.tiles.width + '" '
            + 'tileheight="' + restrictions.tiles.height + '">\n'
            + '<tileset firstgid="1" name="tiles" tilewidth="' + restrictions.tiles.width + '" '
            + 'tileheight="' + restrictions.tiles.height + '">\n'
            + '<image source="' + parts.join('.') + '.combined.png" />\n'
            + '</tileset>\n'
            + '<layer name="bg" width="' + tileMap.width + '" '
            + 'height="' + tileMap.height + '">\n'
            + '<data encoding="csv">\n'
            + rows.join(',\n') + '\n'
            + '</data>\n'
            + '</layer>\n'
            + '</map>\n';

        saveAs(new Blob([text], {type: "application/octet-stream"}), parts.join('.') + '.combined.tmx');

        return false;
    }

    self.loadFile = function(file) {
        filePicker.value = '';

        if(file.type === 'image/png' || file.type === 'image/gif') {
            var image = new Image;
            image.onload = function() {
                try {
                    if(image.width % restrictions.attributes.width != 0 || image.height % restrictions.attributes.height != 0) {
                        throw 'Image "' + file.name + '" has dimensions of '
                            + image.width + 'x' + image.height + ', which ' 
                            + 'are not divisible by the tile attribute size of '
                            + restrictions.attributes.width + 'x' + restrictions.attributes.height + '!';
                        return;
                    }

                    inputCanvas.width = image.width;
                    inputCanvas.height = image.height;
                    inputCanvas.style.display = 'block';

                    var context = inputCanvas.getContext('2d')
                    context.drawImage(image, 0, 0);

                    restrictions.tiles.max = +tileLimitField.value;
                    restrictions.tiles.removeDuplicates = removeDuplicatesCheckbox.checked;
                    restrictions.palettes.commonBackgroundMode = commonBackgroundCheckbox.checked;

                    var pixels = context.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
                    var attributeMap = generateAttributeMap(pixels);
                    var tileMap = generateTileMap(pixels, attributeMap);
                    var paletteTable = generatePaletteTable(attributeMap.palettes);

                    tilesetContainer.innerHTML = '';
                    tileMap.tileCanvas.style.display = 'block';
                    var h2 = document.createElement('h2');
                    h2.appendChild(document.createTextNode('Tileset'));
                    tilesetContainer.appendChild(h2);
                    var p = document.createElement('p');
                    p.appendChild(document.createTextNode(tileMap.tiles.length + ' tile(s) of ' + restrictions.tiles.width + ' x ' + restrictions.tiles.height + ' pixels'));
                    tilesetContainer.appendChild(p);
                    tilesetContainer.appendChild(tileMap.tileCanvas);
                    var p = document.createElement('p');
                    var a = document.createElement('a');
                    a.onclick = self.saveCHR;
                    a.appendChild(document.createTextNode('Save raw GB tileset (.chr)...'));
                    p.appendChild(a);
                    tilesetContainer.appendChild(p);
                    var p = document.createElement('p');
                    var a = document.createElement('a');
                    a.onclick = self.saveTilePNG;
                    a.appendChild(document.createTextNode('Save tile set (.tiles.png)...'));
                    p.appendChild(a);
                    tilesetContainer.appendChild(p);
                    var p = document.createElement('p');
                    var a = document.createElement('a');
                    a.onclick = self.saveCombinedPNG;
                    a.appendChild(document.createTextNode('Save combined tile set (.combined.png)...'));
                    p.appendChild(a);
                    tilesetContainer.appendChild(p);

                    paletteContainer.innerHTML = '';
                    var h2 = document.createElement('h2');
                    h2.appendChild(document.createTextNode('Palettes'));
                    paletteContainer.appendChild(h2);
                    var p = document.createElement('p');
                    p.appendChild(document.createTextNode(attributeMap.palettes.length + ' palette(s) of ' + restrictions.colors.max + ' colors'));
                    paletteContainer.appendChild(p);
                    paletteContainer.appendChild(paletteTable);
                    var p = document.createElement('p');
                    var a = document.createElement('a');
                    a.onclick = self.savePal;
                    a.appendChild(document.createTextNode('Save raw 15-bit palette (.pal)...'));
                    p.appendChild(a);
                    paletteContainer.appendChild(p);
                    var p = document.createElement('p');
                    var a = document.createElement('a');
                    a.onclick = self.saveAttrPNG;
                    a.appendChild(document.createTextNode('Save attribute set (.attributes.png)...'));
                    p.appendChild(a);
                    paletteContainer.appendChild(p);

                    mapContainer.innerHTML = '';
                    var h2 = document.createElement('h2');
                    h2.appendChild(document.createTextNode('Map'));
                    mapContainer.appendChild(h2);
                    var p = document.createElement('p');
                    p.appendChild(document.createTextNode('Attribute Map: ' + attributeMap.width + ' x ' + attributeMap.height));
                    mapContainer.appendChild(p);
                    var p = document.createElement('p');
                    p.appendChild(document.createTextNode('Tile Map: ' + tileMap.width + ' x ' + tileMap.height));
                    mapContainer.appendChild(p);
                    var p = document.createElement('p');
                    var a = document.createElement('a');
                    a.onclick = self.saveTileMapCSV;
                    a.appendChild(document.createTextNode('Save tile map (.tiles.csv)...'));
                    p.appendChild(a);
                    mapContainer.appendChild(p);
                    var p = document.createElement('p');
                    var a = document.createElement('a');
                    a.onclick = self.saveAttrMapCSV;
                    a.appendChild(document.createTextNode('Save attribute map (.attributes.csv)...'));
                    p.appendChild(a);
                    mapContainer.appendChild(p);
                    var p = document.createElement('p');
                    var a = document.createElement('a');
                    a.onclick = self.saveCombinedMapCSV;
                    a.appendChild(document.createTextNode('Save combined map (.combined.csv)...'));
                    p.appendChild(a);
                    mapContainer.appendChild(p);
                    var p = document.createElement('p');
                    var a = document.createElement('a');
                    a.onclick = self.saveCombinedMapTiled;
                    a.appendChild(document.createTextNode('Save combined tiled map (.combined.tmx)...'));
                    p.appendChild(a);
                    mapContainer.appendChild(p);
                    var p = document.createElement('p');
                    p.appendChild(document.createTextNode('Binary formats have the following layout: width : uint16, height : uint16, data : uint8[width * height]'));
                    mapContainer.appendChild(p);
                    var p = document.createElement('p');
                    var a = document.createElement('a');
                    a.onclick = self.saveTileMapDat;
                    a.appendChild(document.createTextNode('Save binary tile map (.tiles.dat)...'));
                    p.appendChild(a);
                    mapContainer.appendChild(p);
                    var p = document.createElement('p');
                    var a = document.createElement('a');
                    a.onclick = self.saveAttrMapDat;
                    a.appendChild(document.createTextNode('Save binary attribute map (.attributes.dat)...'));
                    p.appendChild(a);
                    mapContainer.appendChild(p);

                    tilesetContainer.className = 'section tileset';
                    paletteContainer.className = 'section palettes';
                    mapContainer.className = 'section map';

                    currentMap = {
                        tileMap: tileMap,
                        attributeMap: attributeMap,
                    };
                } catch(e) {
                    alert(e);
                    console.log(e);
                    if(typeof(e.stack) !== 'undefined') {
                        console.log(e.stack);
                    }
                    throw e;
                }

            };
            image.src = URL.createObjectURL(file);
        }
    };

    var generatePaletteTable = function(palettes) {
        var table = document.createElement('table');        
        for(var i = 0; i < palettes.length; i++) {
            var palette = palettes[i].colors.values;

            var tr = document.createElement('tr');
            tr.className = 'source_palette';
            for(var j = 0; j < palette.length; j++) {
                var td = document.createElement('td');
                var div = document.createElement('div');
                div.className = 'color';
                div.style.backgroundColor = 'rgba(' + palette[j].join(',') + ')';
                td.appendChild(div);
                tr.appendChild(td);
            }
            table.appendChild(tr);
        }
        return table;
    }    

    var calculateColorSet = function(pixels, x, y) {
        var colors = {_size: 0};
        var width = pixels.width;
        var data = pixels.data;
        for(j = 0; j < restrictions.attributes.height; j++) {
            for(i = 0; i < restrictions.attributes.width; i++) {
                var p = ((y + j) * width + (x + i)) * 4;
                var c = [data[p], data[p + 1], data[p + 2], data[p + 3]];
                var k = c.join(',');

                if(restrictions.palettes.commonBackgroundMode && x + i == 0 && y + j == 0) {
                    colors.commonColor = c;
                }

                if(!colors[k]) {
                    colors[k] = c;
                    colors._size++;

                    if(colors._size > restrictions.colors.max) {
                        throw 'too many colors in chunk from (' + x + ', ' + y + ') to (' + (x + restrictions.attributes.width - 1)  + ', ' + (y + restrictions.attributes.height - 1) + ')';
                    }
                }
            }
        }
        return colors;
    }

    var sortedColorSet = function(commonColor, colors) {
        var array = [];
        for(var k in colors) {
            if(k != '_size') {
                array.push([k, colors[k]]);
            }
        }

        // Sort the colors by naive greyscale brightness, followed by RGBA.
        array.sort(function(v, v2) {
            var a = v[1];
            var b = v2[1];
            var grey = (a[0] + a[1] + a[2]) / 3
            var grey2 = (b[0] + b[1] + b[2]) / 3
            if(grey != grey2) {
                return grey - grey2;
            } else if(a[0] != b[0]) {
                return a[0] - b[0];
            } else if(a[1] != b[1]) {
                return a[1] - b[1];
            } else if(a[2] != b[2]) {
                return a[2] - b[2];
            } else if(a[3] != b[3]) {
                return a[3] - b[3];
            } else {
                return 0;
            }
        });

        if(commonColor) {
            for(var i = 0; i < array.length; i++) {
                var c = array[i][1];
                if(c[0] == commonColor[0]
                && c[1] == commonColor[1]
                && c[2] == commonColor[2]
                && c[3] == commonColor[3]) {
                    array.unshift(array.splice(i, 1)[0]);
                    break;
                }
            }
        }

        var ordering = {};
        var values = [];
        for(var i = 0; i < array.length; i++) {
            var item = array[i];
            ordering[item[0]] = values.length;
            values.push(item[1]);
        }

        return {ordering: ordering, values: values};
    }

    var keysToString = function(o) {
        var keys = [];
        for(var k in o) {
            keys.push(k);
        }
        return keys.sort().join(':');
    }

    var isSubset = function(o, o2) {
        for(var k in o) {
            if(k != '_size' && !o2[k]) {
                return false;
            }
        }
        return true;
    }

    var generateAttributeMap = function(pixels) {
        var map = {
            width: pixels.width / restrictions.attributes.width,
            height: pixels.height / restrictions.attributes.height,
            data: [],
            palettes: [],
            commonColor: null,
        }

        var palettes = {};
        var index = 0;
        for(var y = 0; y < pixels.height; y += restrictions.attributes.height)  {
            for(var x = 0; x < pixels.width; x += restrictions.attributes.width)  {
                var colors = calculateColorSet(pixels, x, y);

                if(restrictions.palettes.commonBackgroundMode && x == 0 && y == 0) {
                    map.commonColor = colors.commonColor;
                    delete colors.commonColor;
                }

                var k = keysToString(colors);

                if(!palettes[k]) {
                    palettes[k] = {
                        colors: colors,
                        index: index
                    }
                    index++;
                }
                map.data.push(palettes[k].index);
            }
        }

        var reductions = {};
        for(var k in palettes) {
            var index = palettes[k].index;
            reductions[index] = palettes[k];
        }

        var changed = false;
        do {
            changed = false;
            // Merge palettes which are strict subsets of others.
            for(var k in palettes) {
                for(var k2 in palettes) {
                    if(k != k2) {
                        var p = palettes[k];
                        var p2 = palettes[k2];
                        if(isSubset(p.colors, p2.colors)) {
                            reductions[p.index] = reductions[p2.index];
                            delete palettes[k];
                            changed = true;
                            break;
                        }
                    }
                }
            }

            if(restrictions.palettes.combineIncompleteEntries) {
                // Merge palettes when they can fit together within the color limit.
                for(k in palettes) {
                    for(k2 in palettes) {
                        if(k != k2) {
                            var p = palettes[k];
                            var p2 = palettes[k2];
                            if(p.colors._size + p2.colors._size <= restrictions.colors.max) {
                                p.colors._size = p.colors._size + p2.colors._size;
                                for(k in p2.colors) {
                                    if(k != '_size') {
                                        p.colors[k] = p2.colors[k];
                                    }
                                }

                                reductions[p2.index] = reductions[p.index];

                                delete palettes[k2];
                                changed = true;
                                break;
                            }
                        }
                    }
                }
            }
        } while(changed);

        for(var k in reductions) {
            while(reductions[k] != reductions[reductions[k].index]) {
                reductions[k] = reductions[reductions[k].index];
            }
        }

        for(var k in palettes) {
            palettes[k].colors = sortedColorSet(map.commonColor, palettes[k].colors);
            palettes[k].index = map.palettes.length;
            map.palettes.push(palettes[k]);
        }

        if(map.palettes.length > restrictions.palettes.max) {
            throw 'too many palettes';
        }

        for(var y = 0; y < map.height; y++) {
            for(var x = 0; x < map.width; x++) {
                map.data[y * map.width + x] = reductions[map.data[y * map.width + x]].index;
            }
        }

        return map;
    };

    var calculateTilePattern = function(pixels, attributeMap, x, y) {
        var pattern = [];
        var width = pixels.width;
        var data = pixels.data;
        for(j = 0; j < restrictions.tiles.height; j++) {
            for(i = 0; i < restrictions.tiles.width; i++) {
                var p = ((y + j) * width + (x + i)) * 4;
                var c = [data[p], data[p + 1], data[p + 2], data[p + 3]];
                var k = c.join(',');
                var colors = attributeMap.palettes[attributeMap.data[
                    Math.floor((y + j) / restrictions.attributes.height) * attributeMap.width
                    + Math.floor((x + i) / restrictions.attributes.width)]].colors;
                pattern.push(colors.ordering[k]);
            }
        }
        return pattern;
    }

    var createTilesetImage = function(tiles, palette) {
        var canvas = document.createElement('canvas');

        // Try to fit this in a nice rectangular region, so it's easier to view.
        var columns = Math.min(tiles.length, 16);
        var rows = Math.ceil(tiles.length / 16);

        canvas.width = columns * restrictions.tiles.width;
        canvas.height = rows * restrictions.tiles.height;
        var out = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
        for(var i = 0; i < tiles.length; i++) {
            for(var y = 0; y < restrictions.tiles.height; y++) {
                for(var x = 0; x < restrictions.tiles.width; x++) {
                    var p = ((Math.floor(i / columns) * restrictions.tiles.height + y) * canvas.width
                        + (i % columns) * restrictions.tiles.width + x) * 4;
                    var c = palette[tiles[i].pattern[y * restrictions.tiles.width + x]];
                    out.data[p + 0] = c[0];
                    out.data[p + 1] = c[1];
                    out.data[p + 2] = c[2];
                    out.data[p + 3] = 255;
                }
            }
        }
        canvas.getContext('2d').putImageData(out, 0, 0);
        return canvas;
    }

    var generateTileMap = function(pixels, attributeMap) {
        var map = {
            width: pixels.width / restrictions.tiles.width,
            height: pixels.height / restrictions.tiles.height,
            tiles: [],
            data: []
        }

        var tiles = {};
        var index = 0;
        for(var y = 0; y < pixels.height; y += restrictions.attributes.height)  {
            for(var x = 0; x < pixels.width; x += restrictions.attributes.width)  {
                var t = calculateTilePattern(pixels, attributeMap, x, y);
                var k = t.join(',');
                if(!restrictions.tiles.removeDuplicates) {
                    k = index;
                }
                if(!tiles[k]) {
                    tiles[k] = {
                        pattern: t,
                        index: index
                    }
                    map.tiles.push(tiles[k]);
                    index++;
                }

                map.data.push(tiles[k].index);
            }
        }

        tiles = map.tiles;
        if(tiles.length > restrictions.tiles.max) {
            throw 'too many tiles';
        }

        var canvas = createTilesetImage(tiles, brewtool.getGreyscalePalette());

        map.tileCanvas = canvas;

        return map;
    }

    return self;
})({});
 


</script>
    <script type="text/javascript">
var brewtool = (function(self) {
    var calculateTilesetSize = function(bytes) {
        var tiles = bytes.length / 16;
        if(tiles == 0) {
            return;
        }

        // Try to fit this in a nice rectangular region, so it's easier to view.
        var columns = 0;
        var rows = 0;
        for(var i = 16; i != 1; i /= 2) {
            if(tiles % i == 0) {
                if(i >= 8) {
                    columns = i;
                    rows = tiles / i;
                }
                else {
                    rows = i;
                    columns = tiles / i;
                }
                break;
            }
        }
        if(columns == 0) {
            columns = tiles;
            rows = 1;
        }

        return [rows, columns];
    };

    var getPixelIndices = function(pixels, palette) {
        var table = {};
        for(var i = 0; i < palette.length; i++) {
            table[palette[i].join(',')] = i;
        }

        var result = new Array(pixels.width * pixels.height);
        for(var i = 0, j = 0; i < pixels.width * pixels.height * 4; i += 4, j++) {
            var color = [
                pixels.data[i],
                pixels.data[i + 1],
                pixels.data[i + 2]
            ];
            result[j] = table[color.join(',')];
        }
        return result;
    };

    self.getGreyscalePalette = function() {
        return [
            [0x00, 0x00, 0x00],
            [0x60, 0x60, 0x60],
            [0xC0, 0xC0, 0xC0],
            [0xFF, 0xFF, 0xFF]
        ];
    };

    self.loadTileset = function(bytes, canvas, format, palette) {
        if(format != 'NES'
        && format != 'GB') {
            return;
        }

        var size = calculateTilesetSize(bytes);
        var rows = size[0];
        var columns = size[1];

        canvas.width = columns * 8;
        canvas.height = rows * 8;
        var pixels = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);

        if(format == 'NES') {
            for(var row = 0; row < rows; row++) {
                for(var col = 0; col < columns; col++) {
                    for(var j = 0; j < 8; j++) {
                        var low = bytes.charCodeAt((row * columns + col) * 16 + j);
                        var high = bytes.charCodeAt((row * columns + col) * 16 + j + 8);
                        for(var i = 0; i < 8; i++) {
                            var p = ((row * 8 + j) * columns * 8 + (col * 8 + i)) * 4;
                            var c = palette[((high & (1 << (7 - i))) ? 2 : 0) | ((low & (1 << (7 - i))) ? 1 : 0)]
                            pixels.data[p + 0] = c[0];
                            pixels.data[p + 1] = c[1];
                            pixels.data[p + 2] = c[2];
                            pixels.data[p + 3] = 0xFF;
                        }
                    }
                }
            }
        } else {
            for(var row = 0; row < rows; row++) {
                for(var col = 0; col < columns; col++) {
                    for(var j = 0; j < 8; j++) {
                        var index = ((row * columns + col) * 8 + j) * 2;
                        var low = bytes.charCodeAt(index);
                        var high = bytes.charCodeAt(index + 1);
                        for(var i = 0; i < 8; i++) {
                            var p = ((row * 8 + j) * columns * 8 + (col * 8 + i)) * 4;
                            var c = palette[((high & (1 << (7 - i))) ? 2 : 0) | ((low & (1 << (7 - i))) ? 1 : 0)]

                            pixels.data[p + 0] = c[0];
                            pixels.data[p + 1] = c[1];
                            pixels.data[p + 2] = c[2];
                            pixels.data[p + 3] = 0xFF;
                        }
                    }
                }
            }
        }
        canvas.getContext('2d').putImageData(pixels, 0, 0);
    };

    self.saveTileset = function(canvas, format, palette, callback) {
        if(format != 'NES'
        && format != 'GB'
        && format != 'PNG') {
            return;
        }

        var bytes = [];
        var pixels = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
        var indices = getPixelIndices(pixels, palette);
        if(format == 'NES') {
            for(var y = 0, h = canvas.height; y < h; y += 8) {
                for(var x = 0, w = canvas.width; x < w; x += 8) {
                    for(var j = 0; j < 8; j++) {
                        var low = 0;
                        for(var i = 0; i < 8; i++) {
                            var color = indices[(y + j) * canvas.width + x + i];
                            low = (low << 1) | (color & 0x1);
                        }
                        bytes.push(low);
                    }
                    for(var j = 0; j < 8; j++) {
                        var high = 0;
                        for(var i = 0; i < 8; i++) {
                            var c = indices[(y + j) * canvas.width + x + i];
                            high = (high << 1) | ((c & 0x2) >> 1);
                        }
                        bytes.push(high);
                    }
                }
            }
        } else {
            for(var y = 0, h = canvas.height; y < h; y += 8) {
                for(var x = 0, w = canvas.width; x < w; x += 8) {
                    for(var j = 0; j < 8; j++) {
                        var low = 0;
                        var high = 0;
                        for(var i = 0; i < 8; i++) {
                            var color = indices[(y + j) * canvas.width + x + i];
                            low = (low << 1) | (color & 0x1);
                            high = (high << 1) | ((color & 0x2) >> 1);
                        }
                        bytes.push(low);
                        bytes.push(high);
                    }
                }
            }
        }

        var buffer = new Uint8Array(new ArrayBuffer(bytes.length));
        for(var i = 0; i < bytes.length; i++) {
            buffer[i] = bytes[i];
        }

        callback(new Blob([buffer], {type: "application/octet-stream"}));
    };

    self.loadPalettes = function(bytes) {
        var palettes = [];
        var count = Math.floor(bytes.length / 8);
        for(var i = 0; i < count; i++) {
            var palette = [];
            for(var j = 0; j < 4; j++) {
                var v = bytes.charCodeAt(i * 8 + j * 2) | (bytes.charCodeAt(i * 8 + j * 2 + 1) << 8)
                palette.push([
                    (v & 0x1F) << 3,
                    ((v >> 5) & 0x1F) << 3,
                    ((v >> 10) & 0x1F) << 3,
                ]);
            }
            palettes.push(palette);
        }
        return palettes;
    }

    self.savePalettes = function(palettes, callback) {
        var bytes = [];
        for(var i = 0; i < palettes.length; i++) {
            var palette = palettes[i];
            for(var j = 0; j < palette.length; j++) {
                var r = Math.floor(palette[j][0] * 32 / 256);
                var g = Math.floor(palette[j][1] * 32 / 256);
                var b = Math.floor(palette[j][2] * 32 / 256);
                var c = (r | g << 5 | b << 10);

                bytes.push(c & 0xFF);
                bytes.push((c >> 8) & 0xFF);
            }
        }

        var buffer = new Uint8Array(new ArrayBuffer(bytes.length));
        for(var i = 0; i < bytes.length; i++) {
            buffer[i] = bytes[i];
        }
        callback(new Blob([buffer], {type: "application/octet-stream"}));
    }

    self.loadSprites = function(bytes) {
        var sprites = [];
        var count = Math.floor(bytes.length / 4);
        for(var i = 0; i < count; i++) {
            sprites.push({
                x: bytes.charCodeAt(i * 4),
                y: bytes.charCodeAt(i * 4 + 1),
                tile: bytes.charCodeAt(i * 4 + 2),
                pal: bytes.charCodeAt(i * 4 + 3) & 0x07,
                hflip: !!(bytes.charCodeAt(i * 4 + 3) & 0x20),
                vflip: !!(bytes.charCodeAt(i * 4 + 3) & 0x40),
                behind: !!(bytes.charCodeAt(i * 4 + 3) & 0x80)
            });
        }
        return sprites;
    }

    self.saveSprites = function(sprites, callback) {
        var bytes = [];
        for(var i = 0; i < sprites.length; i++) {
            var sprite = sprites[i];
            bytes.push(sprite.x & 0xFF);
            bytes.push(sprite.y & 0xFF);
            bytes.push(sprite.tile & 0xFF);
            bytes.push((sprite.pal & 0x07) | (sprite.hflip ? 0x20 : 0x00) | (sprite.vflip ? 0x40 : 0x00) | (sprite.behind ? 0x80 : 0x00));
        }

        var buffer = new Uint8Array(new ArrayBuffer(bytes.length));
        for(var i = 0; i < bytes.length; i++) {
            buffer[i] = bytes[i];
        }
        callback(new Blob([buffer], {type: "application/octet-stream"}));
    }

    return self;
})({})
</script>
</head>
<body class="page">
    <h1><a href="#">map zapper</a></h1>
    <h2>by Andrew G. Crowell</h2>
    <p>For turning low-spec images into palettes, tilesets, and tilemaps.</p>
    <div class="editor"></div>
    <script type="text/javascript">
        editor.init({
            element: document.querySelector('.editor'),
        })
    </script>
    <p class="footnote">see also: <a href="https://github.com/Bananattack/brewtool">(source code)</a></p>
</body>
</html>